\input{../Preambulos/pre_documento}
\input{../Preambulos/pre_plantilla_Warsaw_crane}
\input{../Preambulos/pre_codigo}
\input{../Preambulos/pre_define_footers_Warsaw_crane}	
\normalfont
\usepackage{ccfonts}% http://ctan.org/pkg/{ccfonts}
\usepackage[T1]{fontenc}% http://ctan.or/pkg/fontenc
\renewcommand{\rmdefault}{cmr}% cmr = Computer Modern Roman
\linespread{1.3}
\title{Operaciones con matrices en pyhton}
\subtitle{Curso de Física Computacional}
\author{M. en C. Gustavo Contreras Mayén}
\date{\today}
\institute{Facultad de Ciencias - UNAM}
\titlegraphic{\includegraphics[width=1.75cm]{Imagenes/escudo-facultad-ciencias}\hspace*{4.75cm}~%
   \includegraphics[width=1.75cm]{Imagenes/escudo-unam}
}
\begin{document}
\maketitle
\fontsize{14}{14}\selectfont
\spanishdecimal{.}
\section*{Contenido}
\frame{\tableofcontents[currentsection, hideallsubsections]}
\section{Operaciones con matrices}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Operaciones básicas}
\begin{frame}
\frametitle{Operaciones con matrices}
Para fines prácticos, los arreglos (\azulfuerte{\texttt{arrays}}) de \texttt{numpy}, pueden ser utilizados como matrices.
\\
Revisaremos algunas operaciones con matrices de \texttt{numpy}.
\end{frame}
\subsection{Determinantes}
\begin{frame}[fragile]
\frametitle{El determinante}
El determinante de una matriz se calcula mediante la función \azulfuerte{\texttt{det()}}, contenida en el módulo \texttt{numpy.linalg}:
\begin{lstlisting}[caption=Cálculo del determinante, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]

from numpy import array, linalg

a = array([[ 3, -5, 8], [-1, 2, 3], [-5, -6, 2]])

print(linalg.det(a))
\end{lstlisting}
\end{frame}
\subsection{La traza}
\begin{frame}[fragile]
\frametitle{La traza de una matriz}
La traza de una matriz se calcula con la función \azulfuerte{\texttt{trace()}}, contenida en el módulo \texttt{numpy}:
\begin{lstlisting}[caption=Cálculo de la traza, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]

from numpy import array, trace

a = array([[ 3, -5, 8], [-1, 2, 3], [-5, -6, 2]])

print(trace(a))
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{La traza de una matriz - 2}
La función \azulfuerte{\texttt{trace()}}, permite el uso de un parámetro que calcula la traza con un \textcolor{red}{desplazamiento (offset)}:
\begin{verbatim}
trace(matriz, offset)
\end{verbatim}
Donde el \textcolor{red}{offset} es un valor entero:
\begin{itemize}
\item \textcolor{red}{offset} $= k > 0$, número de la k-ésima codiagonal superior (por arriba de la diagonal principal).
\item \textcolor{red}{offset} $= k < 0$, número de la k-ésima codiagonal inferior (por abajo de la diagonal principal).
\end{itemize}
\end{frame}
\begin{frame}[plain, fragile]
\frametitle{La traza de una matriz - 2}
\begin{lstlisting}[caption=Cálculo de la traza con desplazamiento, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]
from numpy import array, trace

a = array([[ 3, -5, 8], [-1, 2, 3], [-5, -6, 2]])

print(trace(a,-1))

print(trace(a,1))

\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Desplazamiento del las matrices}
\begin{figure}
	\centering
	\includestandalone[scale=1.5]{Figuras/matriz_marcada_01}
 	\\ \texttt{trace(a)}
\end{figure}
\end{frame}
\begin{frame}[fragile]
\frametitle{Desplazamiento del las matrices}
\begin{figure}
	\includestandalone[scale=1.5]{Figuras/matriz_marcada_02}
 \\ \texttt{trace(a,-1)}
\end{figure}
\end{frame}
\begin{frame}[fragile]
\frametitle{Desplazamiento del las matrices}
\begin{figure}
	\includestandalone[scale=1.5]{Figuras/matriz_marcada_03}
 \\ \texttt{trace(a,1)}
\end{figure}
\end{frame}
\subsection{La matriz inversa}
\begin{frame}[plain, fragile]
\frametitle{La matriz inversa}
La matriz inversa se calcula con la función \azulfuerte{\texttt{inv()}}, del módulo \texttt{numpy}: 
\begin{lstlisting}[caption=Cálculo de la matriz inversa, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]

from numpy import array, linalg

a = array([[ 3, -5, 8], [-1, 2, 3], [-5, -6, 2]])

print(linalg.inv(a))
\end{lstlisting}
\end{frame}
\subsection{La matriz transpuesta}
\begin{frame}[plain, fragile]
\frametitle{La matriz transpuesta}
La matriz transpuesta se obtiene con la función \azulfuerte{\texttt{transpose()}}, contenida en el módulo \texttt{numpy}: 
\begin{lstlisting}[caption=Cálculo de la matriz transpuesta, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]

from numpy import array, transpose

a = array([[ 3, -5, 8], [-1, 2, 3], [-5, -6, 2]])

print(transpose(a))
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Las matrices como objetos de numpy}
La librería \texttt{numpy} permite manejar las matrices (\azulfuerte{\texttt{arrays}}) como objetos.
\\
\bigskip
Estos objetos de matriz tienen métodos integrados para el cálculo del determinante y de la matriz inversa.
\end{frame}
\begin{frame}[plain, fragile]
\frametitle{Las matrices como objetos}
El convertir el \azulfuerte{\texttt{array}} expresamente a una matrix, podemos manipularla como un objeto de \texttt{numpy}
\begin{lstlisting}[caption=Cálculo de la matriz transpuesta, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]

from numpy import matrix

a = array([[ 3, -5, 8], [-1, 2, 3], [-5, -6, 2]])

a = matrix(a)

print(a.T)

print(a.I)
\end{lstlisting}
\end{frame}
\section{Solución de sistemas algebraicos}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Sistemas algebraicos con \python{}}
\begin{frame}[plain, fragile]
\frametitle{Solución de sistemas algebraicos}
Un sistema de ecuaciones algebraico se puede expresar en términos de un arreglo matricial
\begin{align*}
\begin{aligned}
a_{1} \: x + b_{1} \: y + c_{1} \: z = d_{1} \\
a_{2} \: x + b_{2} \: y + c_{2} \: z = d_{2} \\
a_{3} \: x + b_{3} \: y + c_{3} \: z = d_{3} 
\end{aligned}
\Longrightarrow
\begin{pmatrix}
a_{1} & b_{1} & c_{1} \\ 
a_{2} & b_{2} & c_{2} \\
a_{3} & b_{3} & c_{3} 
\end{pmatrix}
\begin{pmatrix}
x  \\
y  \\
z
\end{pmatrix} = 
\begin{pmatrix}
d_{1}  \\
d_{2}  \\
d_{3}
\end{pmatrix}
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Solución con herramientas}
Existen métodos y funciones con \python{} para resolver sistemas de ecuaciones algebraicas.
\\
\bigskip
Tomemos en cuenta que:
\setbeamercolor{item projected}{bg=red!70!black,fg=white}
\setbeamertemplate{enumerate items}[circle]
\begin{enumerate}[<+->]
\item La solución de sistemas matriciales es computacionalmente una tarea intensa.
\item Veremos algunos métodos para resolver estas ecuaciones.
\item Estos métodos están contenidos en el módulo \azulfuerte{\texttt{scipy.linalg}}.
\end{enumerate}
\end{frame}
\begin{frame}
\frametitle{Ejemplo}
Revisemos algunos métodos usando el siguiente sistema:
\begin{align*}
4 \: x - 5 \: y + 8 \: z &= 4 \\
2 \: x - 8 \: y + 7 \: z &= 0 \\
-5 \: x - 8 \: y &= 4
\end{align*}
\end{frame}
\subsection{La función scipy.linalg.solve}
\begin{frame}
\frametitle{La función scipy.linalg.solve}
Esta función utiliza la matriz de coeficientes y el vector del lado derecho de la igualdad como argumentos, devuelve un vector con la solución:
\end{frame}
\begin{frame}[plain, fragile]
\frametitle{La función scipy.linalg.solve}
\begin{lstlisting}[caption=Uso de la funcion \texttt{solve}, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]
from scipy import linalg as slin
from numpy import array

cm = array([[4, -5, 8], [2, -8, 7], [-5, 8, 0]])

rhs = array([4, 0, -5])

solucion = slin.solve(cm,rhs)
print(solucion)
\end{lstlisting}
\end{frame}
\begin{frame}[plain, fragile]
\frametitle{Consideración importante}
La matriz de coeficientes debe de ser \emph{no singular}, es decir, el determinante de esa matriz debe de ser distinto de cero:
\begin{lstlisting}[caption=El código se interrumpe, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]
cm_2_ = array([[4, -5, 8], [8, -10, 16], [-5, 8, 0]])
rhs_2_ = array([4,8,-5])

print(slin.det(cm_2_))

solucion_2_ = slin.solve(cm_2_,rhs_2_)

print(solucion_2_)
\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Mensaje de error}
\begin{alltt}
solucion2 = slin.solve(cm2,rhs2)

  File "/home/gustavo/anaconda3/lib/
  		python3.5/site-packages/scipy/
  		linalg/basic.py", line 219, in solve
  raise LinAlgError('Matrix is singular.')

\textcolor{red}{LinAlgError}: Matrix is singular.
\end{alltt}
\end{frame}
\begin{frame}
\frametitle{Sistemas algebraicos grandes}
Los sistemas algebraicos de ecuaciones muy grandes implican una carga computacional elevada para resolverlo.
\\
\bigskip
Existen varios métodos especializados para resolver eficientemente esos grandes sistemas de ecuaciones.
\end{frame}
\subsection{Factorización LU}
\begin{frame}
\frametitle{Factorizacion LU}
Si el vector del lado derecho cambia, pero la matriz del coeficientes no cambia, entonces esta matriz puede descomponerse usando la factorización LU.
\\
\bigskip
Esta descomposición LU se puede utilizar para resolver el sistema para cualquier vector del lado derecho.
\end{frame}
\begin{frame}
\frametitle{Factorizacion LU}
Esto ahorra tiempo, porque el proceso de factorización LU es el que implica la mayor carga de recursos.
\\
\bigskip
Por lo que al no tener que rehacerlo cada vez, se ahorra tiempo y recursos computacionales.
\end{frame}
\begin{frame}
\frametitle{Factorización LU}
Para utilizar la factorización LU:
\setbeamercolor{item projected}{bg=red!70!black,fg=white}
\setbeamertemplate{enumerate items}[circle]
\begin{enumerate}[<+->]
\item Primero, usemos la función \azulfuerte{\texttt{slin.lu\_factor()}} en la matriz de coeficientes, y asignamos el resultado en una nueva variable.
\item Segundo, usamos la función \azulfuerte{\texttt{slin.lu\_solve()}} con la factorización obtenida y los el vector de consantes \texttt{rhs} como argumentos.
\end{enumerate}
\end{frame}
\begin{frame}[plain, fragile]
\begin{lstlisting}[caption=Uso de scipy.linalg.lu, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]
from scipy import linalg as slin
from numpy import array

cm = array([[ 4, -5, 8], [ 2, -8, 7], [-5, 8, 0]])

rhs = array([ 4, 0, -5])

#nota: las funciones llevan guion bajo
lu = slin.lu-factor(cm)

solucion = slin.lu-solve(lu,rhs)

print(solucion)
\end{lstlisting}
\end{frame}
\begin{frame}
\frametitle{Ventaja con la factorización LU}
Una vez que se logra la factorización LU, podemos usar cualquier vector del lado derecho, sin necesidad de que se calcule nuevamente la factorización.
\end{frame}
\begin{frame}[plain, fragile]
\begin{lstlisting}[caption=La misma factorización cambiando el vector b, style=FormattedNumber, basicstyle=\linespread{1.1}\ttfamily=\small, columns=fullflexible]
b_2_ =array([4, -3, 9])

#nota: lleva guion bajo
solucion-b_2_ = slin.lu-solve(lu, b_2_)

print('\nSolucion con el vector b_2_')
print(solucion-b_2_)

b_3_ = array([-2, -3, -12])

#nota: lleva guion bajo
solucion-b_3_ = slin.lu-solve(lu, b_3_)

print('\nSolucion con el vector b_3_')
print(solucion-b_32_)
\end{lstlisting}
\end{frame}
\section{Matrices en banda}
\frame{\tableofcontents[currentsection, hideothersubsections]}
\subsection{Resolviendo matrices en banda}
\begin{frame}
\frametitle{Matrices en banda}
Muchas matrices grandes tanto en ciencias como en ingeniería son de tal naturaleza, que los elementos de la misma están agrupados (\emph{en banda}).
\\
\bigskip
Lo que significa que sus valores no nulos se encuentran a lo largo de las diagonales de la matriz.
\end{frame}
\begin{frame}
\frametitle{Matrices en banda}
Se han desarrollado métodos para resolver eficientemente este tipo de matrices.
\\
\bigskip
Las matrices en banda tampoco requieren tanta memoria para almacenar valores intermedios, ya que muchos de las entradas son cero.
\end{frame}
\begin{frame}[plain]
\frametitle{Considera la siguiente matriz en banda}
\begin{align*}
\begin{bmatrix}
1 & -5 & 3 & 0 & 0 & 0 & 0 & 0 \\
3 & 2 & -3 & 5 & 0 & 0 & 0 & 0 \\
0 & -2 & 1 & 5 & 9 & 0 & 0 & 0 \\
0 & 0 & 9 & -1 & 5 & 4 & 0 & 0 \\
0 & 0 & 0 & 0 & 2 & -3 & -2 & 0 \\
0 & 0 & 0 & 0 & 2 & 0 & 1 & -6 \\
0 & 0 & 0 & 0 & 0 & -3 & 2 & 7 \\
0 & 0 & 0 & 0 & 0 & 0 & 9 & 1 
\end{bmatrix}
\end{align*}
\end{frame}
\subsection{Representación de la matriz en banda}
\begin{frame}
\frametitle{Nueva representación de la matriz}
La matriz en banda se puede representar por una matriz no cuadrada del tipo
\pause
\begin{align*}
\begin{bmatrix}
0 & 0 & 3 & 5 & 9 & 4 & -2 & -6 \\
0 & -5 & -3 & 5 & 5 & -3 & 1 & 7 \\
1 & 2 & 1 & -1 & 2 & 0 & 2 & 1 \\
3 & -2 & 9 & 0 & 2 & -3 & 9 & 0 \\
\end{bmatrix}    
\end{align*}
\end{frame}
\begin{frame}[plain]
\frametitle{Diagonales y codiagonales}
\begin{figure}
	\centering
	\includestandalone[scale=0.8]{Figuras/matriz_marcada_04}    
\end{figure}
\end{frame}
\subsection{Arreglo de las codiagonales}
\begin{frame}
\frametitle{Arreglo de las codiagonales}
\begin{figure}
	\centering
	\includestandalone[scale=0.8]{Figuras/matriz_marcada_05}    
\end{figure}
\begin{itemize}
\item Las codiagonales superiores tienen ceros a la izquierda.
\item Las codiagonales inferiores tienen ceros al final.
\end{itemize}
\end{frame}
\subsection{Función scipy.linalg.solve\_banded()}
\begin{frame}[fragile]
\frametitle{Resolviendo matrices en banda}
Para resolver un sistema de ecuaciones con una matriz en banda, usaremos la función \azulfuerte{\texttt{scipy.linalg.solve\_banded()}}.
\\
\bigskip
\pause
La sintaxis para esta función es la siguiente
\begin{alltt}
\azulfuerte{slin.solve_banded((l,u), cm, rhs)}
\end{alltt}
\end{frame}
\begin{frame}[fragile]
\frametitle{Resolviendo matrices en banda}
\begin{alltt}
\azulfuerte{slin.solve_banded((l,u), cm, rhs)}
\end{alltt}
Donde:
\begin{itemize}[<+->]
\item \azulfuerte{\texttt{(l, u)}} es una tupla, donde $l$ es el número de codiagonales inferiores no nulas, y $u$ es el número de codiagonales superiores no nulas.
\item \azulfuerte{\texttt{cm}} es la matriz en banda de coeficientes.
\item \azulfuerte{\texttt{rhs}} es el vector de constantes del lado derecho.
\end{itemize}
\end{frame}
\begin{frame}[plain]
\frametitle{Ejercicio 1 - Matriz en banda}
Resuelve el siguiente sistema algebraico
\begin{align*}
\begin{bmatrix}
1 & -5 & 3 & 0 & 0 & 0 & 0 & 0 \\
3 & 2 & -3 & 5 & 0 & 0 & 0 & 0 \\
0 & -2 & 1 & 5 & 9 & 0 & 0 & 0 \\
0 & 0 & 9 & -1 & 5 & 4 & 0 & 0 \\
0 & 0 & 0 & 0 & 2 & -3 & -2 & 0 \\
0 & 0 & 0 & 0 & 2 & 0 & 1 & -6 \\
0 & 0 & 0 & 0 & 0 & -3 & 2 & 7 \\
0 & 0 & 0 & 0 & 0 & 0 & 9 & 1 
\end{bmatrix}
\begin{bmatrix}
a \\
b \\
c \\
d \\
e \\
f \\
g \\
h
\end{bmatrix}
=
\begin{bmatrix}
5 \\
3 \\
-3 \\
2 \\
0 \\
7 \\
8 \\
1
\end{bmatrix}
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Solución al sistema}
\begin{align*}
a &= 200.639937 \\
b &= -25.491352 \\
c &= -107.698899 \\
d &= -174.206761 \\
e &= 102.750000 \\
f &= 70.833333 \\
g &= -3.500000 \\
h &= 32.500000
\end{align*}
\end{frame}
\begin{frame}
\frametitle{Ejercicio 2 - Matriz tridiagonal simétrica}
Usando la función \azulfuerte{\texttt{solve\_banded()}}, resuelve el sistema $\mathbf{A \: x} = \mathbf{b}$ (que ya habíamos trabajado), donde
\begin{equation*} 
\mathbf{A} =  \begin{bmatrix}
2 & -1 & 0 & 0 & 0 \\
-1 & 2 & -1 & 0 & 0 \\
0 & -1 & 2 & -1 & 0 \\
0 & 0 & -1 & 2 & -1 \\
0 & 0 & 0 & -1 & 2
\end{bmatrix}
\hspace{1cm}
\mathbf{b} =
\begin{bmatrix}
5 \\
-5 \\
4 \\
-5 \\
5
\end{bmatrix}
\end{equation*}
\end{frame}
\begin{frame}
\frametitle{Solución al sistema tridiagonal simétrico}
Cuando usamos las funciones \azulfuerte{\texttt{LUdescomp3}} y \azulfuerte{\texttt{LUsoluc3}} para este sistema tridiagonal simétrico, la solución obtenida es:
\\
\bigskip
\pause
\[x = [ 2. \; -1. \;\; 1. \; -1. \;\;  2.] \]
Que debe de ser la misma solución con la función \azulfuerte{\texttt{solve\_banded()}}
\end{frame}
\end{document}